<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Async broadcast channel"><title>async_broadcast - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="async_broadcast" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../async_broadcast/index.html">async_broadcast</a><span class="version">0.5.1</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../async_broadcast/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">async_broadcast</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/async_broadcast/lib.rs.html#1-1877">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Async broadcast channel</p>
<p>An async multi-producer multi-consumer broadcast channel, where each consumer gets a clone of every
message sent on the channel. For obvious reasons, the channel can only be used to broadcast types
that implement <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone"><code>Clone</code></a>.</p>
<p>A channel has the <a href="struct.Sender.html" title="struct async_broadcast::Sender"><code>Sender</code></a> and <a href="struct.Receiver.html" title="struct async_broadcast::Receiver"><code>Receiver</code></a> side. Both sides are cloneable and can be shared
among multiple threads.</p>
<p>When all <code>Sender</code>s or all <code>Receiver</code>s are dropped, the channel becomes closed. When a channel is
closed, no more messages can be sent, but remaining messages can still be received.</p>
<p>The channel can also be closed manually by calling <a href="struct.Sender.html#method.close" title="method async_broadcast::Sender::close"><code>Sender::close()</code></a> or <a href="struct.Receiver.html#method.close" title="method async_broadcast::Receiver::close"><code>Receiver::close()</code></a>.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_broadcast::{broadcast, TryRecvError};
<span class="kw">use </span>futures_lite::{future::block_on, stream::StreamExt};

block_on(<span class="kw">async move </span>{
    <span class="kw">let </span>(s1, <span class="kw-2">mut </span>r1) = broadcast(<span class="number">2</span>);
    <span class="kw">let </span>s2 = s1.clone();
    <span class="kw">let </span><span class="kw-2">mut </span>r2 = r1.clone();

    <span class="comment">// Send 2 messages from two different senders.
    </span>s1.broadcast(<span class="number">7</span>).<span class="kw">await</span>.unwrap();
    s2.broadcast(<span class="number">8</span>).<span class="kw">await</span>.unwrap();

    <span class="comment">// Channel is now at capacity so sending more messages will result in an error.
    </span><span class="macro">assert!</span>(s2.try_broadcast(<span class="number">9</span>).unwrap_err().is_full());
    <span class="macro">assert!</span>(s1.try_broadcast(<span class="number">10</span>).unwrap_err().is_full());

    <span class="comment">// We can use `recv` method of the `Stream` implementation to receive messages.
    </span><span class="macro">assert_eq!</span>(r1.next().<span class="kw">await</span>.unwrap(), <span class="number">7</span>);
    <span class="macro">assert_eq!</span>(r1.recv().<span class="kw">await</span>.unwrap(), <span class="number">8</span>);
    <span class="macro">assert_eq!</span>(r2.next().<span class="kw">await</span>.unwrap(), <span class="number">7</span>);
    <span class="macro">assert_eq!</span>(r2.recv().<span class="kw">await</span>.unwrap(), <span class="number">8</span>);

    <span class="comment">// All receiver got all messages so channel is now empty.
    </span><span class="macro">assert_eq!</span>(r1.try_recv(), <span class="prelude-val">Err</span>(TryRecvError::Empty));
    <span class="macro">assert_eq!</span>(r2.try_recv(), <span class="prelude-val">Err</span>(TryRecvError::Empty));

    <span class="comment">// Drop both senders, which closes the channel.
    </span>drop(s1);
    drop(s2);

    <span class="macro">assert_eq!</span>(r1.try_recv(), <span class="prelude-val">Err</span>(TryRecvError::Closed));
    <span class="macro">assert_eq!</span>(r2.try_recv(), <span class="prelude-val">Err</span>(TryRecvError::Closed));
})</code></pre></div>
<h3 id="difference-with-async-channel"><a href="#difference-with-async-channel">Difference with <code>async-channel</code></a></h3>
<p>This crate is similar to <a href="https://crates.io/crates/async-channel"><code>async-channel</code></a> in that they both provide an MPMC channel but the
main difference being that in <code>async-channel</code>, each message sent on the channel is only received
by one of the receivers. <code>async-broadcast</code> on the other hand, delivers each message to every
receiver (IOW broadcast) by cloning it for each receiver.</p>
<h3 id="difference-with-other-broadcast-crates"><a href="#difference-with-other-broadcast-crates">Difference with other broadcast crates</a></h3>
<ul>
<li>
<p><a href="https://crates.io/crates/broadcaster"><code>broadcaster</code></a>: The main difference would be that <code>broadcaster</code> doesn’t have a sender and
receiver split and both sides use clones of the same BroadcastChannel instance. The messages
are sent are sent to all channel clones. While this can work for many cases, the lack of
sender and receiver split, means that often times, you’ll find yourself having to drain the
channel on the sending side yourself.</p>
</li>
<li>
<p><a href="https://crates.io/crates/postage"><code>postage</code></a>: this crate provides a <a href="https://docs.rs/postage/0.4.1/postage/broadcast/fn.channel.html">broadcast API</a> similar to <code>async_broadcast</code>. However,
it:</p>
<ul>
<li>(at the time of this writing) duplicates <a href="https://crates.io/crates/futures">futures</a> API, which isn’t ideal.</li>
<li>Does not support overflow mode nor has the concept of inactive receivers, so a slow or
inactive receiver blocking the whole channel is not a solvable problem.</li>
<li>Provides all kinds of channels, which is generally good but if you just need a broadcast
channel, <code>async_broadcast</code> is probably a better choice.</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/tokio/1.6.0/tokio/sync"><code>tokio::sync</code></a>: Tokio’s <code>sync</code> module provides a <a href="https://docs.rs/tokio/1.6.0/tokio/sync/broadcast/index.html">broadcast channel</a> API. The differences
here are:</p>
<ul>
<li>While this implementation does provide <a href="https://docs.rs/tokio/1.6.0/tokio/sync/broadcast/index.html#lagging">overflow mode</a>, it is the default behavior and not
opt-in.</li>
<li>There is no equivalent of inactive receivers.</li>
<li>While it’s possible to build tokio with only the <code>sync</code> module, it comes with other APIs that
you may not need.</li>
</ul>
</li>
</ul>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.InactiveReceiver.html" title="struct async_broadcast::InactiveReceiver">InactiveReceiver</a></div><div class="desc docblock-short">An inactive  receiver.</div></li><li><div class="item-name"><a class="struct" href="struct.Receiver.html" title="struct async_broadcast::Receiver">Receiver</a></div><div class="desc docblock-short">The receiving side of a channel.</div></li><li><div class="item-name"><a class="struct" href="struct.Recv.html" title="struct async_broadcast::Recv">Recv</a></div><div class="desc docblock-short">A future returned by <a href="struct.Receiver.html#method.recv" title="method async_broadcast::Receiver::recv"><code>Receiver::recv()</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Send.html" title="struct async_broadcast::Send">Send</a></div><div class="desc docblock-short">A future returned by <a href="struct.Sender.html#method.broadcast" title="method async_broadcast::Sender::broadcast"><code>Sender::broadcast()</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.SendError.html" title="struct async_broadcast::SendError">SendError</a></div><div class="desc docblock-short">An error returned from <a href="struct.Sender.html#method.broadcast" title="method async_broadcast::Sender::broadcast"><code>Sender::broadcast()</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Sender.html" title="struct async_broadcast::Sender">Sender</a></div><div class="desc docblock-short">The sending side of the broadcast channel.</div></li></ul><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.RecvError.html" title="enum async_broadcast::RecvError">RecvError</a></div><div class="desc docblock-short">An error returned from <a href="struct.Receiver.html#method.recv" title="method async_broadcast::Receiver::recv"><code>Receiver::recv()</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.TryRecvError.html" title="enum async_broadcast::TryRecvError">TryRecvError</a></div><div class="desc docblock-short">An error returned from <a href="struct.Receiver.html#method.try_recv" title="method async_broadcast::Receiver::try_recv"><code>Receiver::try_recv()</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.TrySendError.html" title="enum async_broadcast::TrySendError">TrySendError</a></div><div class="desc docblock-short">An error returned from <a href="struct.Sender.html#method.try_broadcast" title="method async_broadcast::Sender::try_broadcast"><code>Sender::try_broadcast()</code></a>.</div></li></ul><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.broadcast.html" title="fn async_broadcast::broadcast">broadcast</a></div><div class="desc docblock-short">Create a new broadcast channel.</div></li></ul></section></div></main></body></html>