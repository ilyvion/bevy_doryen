<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bevy Pointer"><title>bevy_ptr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-081576b923113409.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bevy_ptr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0 (129f3b996 2024-06-10)" data-channel="1.79.0" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-e32f0c247825364d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-09095024cf37855e.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../bevy_ptr/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../bevy_ptr/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../bevy_ptr/index.html">bevy_ptr</a><span class="version">0.14.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../bevy_ptr/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">bevy_ptr</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/bevy_ptr/lib.rs.html#1-625">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="bevy-pointer"><a class="doc-anchor" href="#bevy-pointer">§</a>Bevy Pointer</h2>
<p><a href="https://github.com/bevyengine/bevy#license"><img src="https://img.shields.io/badge/license-MIT%2FApache-blue.svg" alt="License" /></a>
<a href="https://crates.io/crates/bevy_ptr"><img src="https://img.shields.io/crates/v/bevy_ptr.svg" alt="Crates.io" /></a>
<a href="https://crates.io/crates/bevy_ptr"><img src="https://img.shields.io/crates/d/bevy_ptr.svg" alt="Downloads" /></a>
<a href="https://docs.rs/bevy_ptr/latest/bevy_ptr/"><img src="https://docs.rs/bevy_ptr/badge.svg" alt="Docs" /></a>
<a href="https://discord.gg/bevy"><img src="https://img.shields.io/discord/691052431525675048.svg?label=&amp;logo=discord&amp;logoColor=ffffff&amp;color=7389D8&amp;labelColor=6A7EC2" alt="Discord" /></a></p>
<p>Pointers in computer programming are objects that store a memory address. They’re a fundamental building block for constructing more
complex data structures.</p>
<p>They’re also <em>the</em> definitive source of memory safety bugs: you can dereference a invalid (null) pointer, access a pointer after the underlying
memory has been freed, and even ignore type safety and misread or mutate the underlying memory improperly.</p>
<p>Rust is a programming language that heavily relies on its types to enforce correctness, and by proxy, memory safety. As a result,
Rust has an entire zoo of types for working with pointers, and a graph of safe and unsafe conversions that make working with them safer.</p>
<p><code>bevy_ptr</code> is a crate that attempts to bridge the gap between the full blown unsafety of <code>*mut ()</code> and the safe <code>&amp;'a T</code>, allowing users
to choose what invariants to uphold for their pointer, with the intent to enable building progressively safer abstractions.</p>
<h3 id="how-to-build-a-borrow-from-scratch"><a class="doc-anchor" href="#how-to-build-a-borrow-from-scratch">§</a>How to Build a Borrow (From Scratch)</h3>
<p>Correctly and safety converting a pointer into a valid borrow is at the core of all <code>unsafe</code> code in Rust. Looking at the documentation for
[<code>(*const T)::as_ref</code>], a pointer must satisfy <em>all</em> of the following conditions:</p>
<ul>
<li>The pointer must be properly aligned.</li>
<li>The pointer cannot be null, even for zero sized types.</li>
<li>The pointer must be within bounds of a valid allocated object (on the stack or the heap).</li>
<li>The pointer must point to an initialized instance of <code>T</code>.</li>
<li>The newly assigned lifetime should be valid for the value that the pointer is targeting.</li>
<li>The code must enforce Rust’s aliasing rules. Only one mutable borrow or arbitrarily many read-only borrows may exist to a value at any given moment
in time, and converting from <code>&amp;T</code> to <code>&amp;mut T</code> is never allowed.</li>
</ul>
<p>Note these rules aren’t final and are still in flux as the Rust Project hashes out what exactly are the pointer aliasing rules, but the expectation is that the
final set of constraints are going to be a superset of this list, not a subset.</p>
<p>This list already is non-trivial to satisfy in isolation. Thankfully, the Rust core/standard library provides a progressive list of pointer types that help
build these safety guarantees…</p>
<h3 id="standard-pointers"><a class="doc-anchor" href="#standard-pointers">§</a>Standard Pointers</h3><div><table><thead><tr><th>Pointer Type</th><th>Lifetime’ed</th><th>Mutable</th><th>Strongly Typed</th><th>Aligned</th><th>Not Null</th><th>Forbids Aliasing</th><th>Forbids Arithmetic</th></tr></thead><tbody>
<tr><td><code>Box&lt;T&gt;</code></td><td>Owned</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>&amp;'a mut T</code></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>&amp;'a T</code></td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td><code>&amp;'a UnsafeCell&lt;T&gt;</code></td><td>Yes</td><td>Maybe</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>NonNull&lt;T&gt;</code></td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td><code>*const T</code></td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td><code>*mut T</code></td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td><code>*const ()</code></td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td><code>*mut ()</code></td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td></tr>
</tbody></table>
</div>
<p><code>&amp;T</code>, <code>&amp;mut T</code>, and <code>Box&lt;T&gt;</code> are by far the most common pointer types that Rust developers will see. They’re the only ones in this list that are entirely usable
without the use of <code>unsafe</code>.</p>
<p><code>&amp;UnsafeCell&lt;T&gt;</code> is the first step away from safety. <code>UnsafeCell</code> is the <em>only</em> way to get a mutable borrow from an immutable one in the language, so it’s the
base primitive for all interior mutability in the language: <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, <code>Mutex&lt;T&gt;</code>, <code>RwLock&lt;T&gt;</code>, etc. are all built on top of
<code>UnsafeCell&lt;T&gt;</code>. To safety convert <code>&amp;UnsafeCell&lt;T&gt;</code> into a <code>&amp;T</code> or <code>&amp;mut T</code>, the caller must guarantee that all simultaneous access follow Rust’s aliasing rules.</p>
<p><code>NonNull&lt;T&gt;</code> takes quite a step down from the aforementioned types. In addition to allowing aliasing, it’s the first pointer type on this list to drop both
lifetimes and the alignment guarantees of borrows. Its only guarantees are that the pointer is not null and that it points to a valid instance
of type <code>T</code>. If you’ve ever worked with C++, <code>NonNull&lt;T&gt;</code> is very close to a C++ reference (<code>T&amp;</code>).</p>
<p><code>*const T</code> and <code>*mut T</code> are what most developers with a background in C or C++ would consider pointers.</p>
<p><code>*const ()</code> is the bottom of this list. They’re the Rust equivalent to C’s <code>void*</code>.  Note that Rust doesn’t formally have a concept of type that holds an arbitrary
untyped memory address. Pointing at the unit type (or some other zero-sized type) just happens to be the convention. The only way to reasonably use them is to
cast back to a typed pointer. They show up occasionally when dealing with FFI and the rare occasion where dynamic dispatch is required, but a trait is too
constraining of an interface to work with. A great example of this are the <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a> APIs, where a singular trait (or set of traits) may be insufficient to capture
all usage patterns. <code>*mut ()</code> should only be used to carry the mutability of the target, and as there is no way to mutate an unknown type.</p>
<h3 id="available-in-nightly"><a class="doc-anchor" href="#available-in-nightly">§</a>Available in Nightly</h3><div><table><thead><tr><th>Pointer Type</th><th>Lifetime’ed</th><th>Mutable</th><th>Strongly Typed</th><th>Aligned</th><th>Not Null</th><th>Forbids Aliasing</th><th>Forbids Arithmetic</th></tr></thead><tbody>
<tr><td><code>Unique&lt;T&gt;</code></td><td>Owned</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>Shared&lt;T&gt;</code></td><td>Owned*</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr>
</tbody></table>
</div>
<p><code>Unique&lt;T&gt;</code> is currently available in <code>core::ptr</code> on nightly Rust builds. It’s a pointer type that acts like it owns the value it points to. It can be thought of
as a <code>Box&lt;T&gt;</code> that does not allocate on initialization or deallocated when it’s dropped, and is in fact used to implement common types like <code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>,
etc.</p>
<p><code>Shared&lt;T&gt;</code> is currently available in <code>core::ptr</code> on nightly Rust builds. It’s the pointer that backs both <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>. Its semantics allow for
multiple instances to collectively own the data it points to, and as a result, forbids getting a mutable borrow.</p>
<p><code>bevy_ptr</code> does not support these types right now, but may support <a href="https://en.wikipedia.org/wiki/Polyfill_(programming)">polyfills</a> for these pointer types if the need arises.</p>
<h3 id="available-in-bevy_ptr"><a class="doc-anchor" href="#available-in-bevy_ptr">§</a>Available in <code>bevy_ptr</code></h3><div><table><thead><tr><th>Pointer Type</th><th>Lifetime’ed</th><th>Mutable</th><th>Strongly Typed</th><th>Aligned</th><th>Not Null</th><th>Forbids Aliasing</th><th>Forbids Arithmetic</th></tr></thead><tbody>
<tr><td><code>ConstNonNull&lt;T&gt;</code></td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td><code>ThinSlicePtr&lt;'a, T&gt;</code></td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>OwningPtr&lt;'a&gt;</code></td><td>Yes</td><td>Yes</td><td>No</td><td>Maybe</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><code>Ptr&lt;'a&gt;</code></td><td>Yes</td><td>No</td><td>No</td><td>Maybe</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td><code>PtrMut&lt;'a&gt;</code></td><td>Yes</td><td>Yes</td><td>No</td><td>Maybe</td><td>Yes</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p><code>ConstNonNull&lt;T&gt;</code> is like <code>NonNull&lt;T&gt;</code> but disallows safe conversions into types that allow mutable access to the value it points to. It’s the <code>*const T</code> to
<code>NonNull&lt;T&gt;</code>’s <code>*mut T</code>.</p>
<p><code>ThinSlicePtr&lt;'a, T&gt;</code> is a <code>&amp;'a [T]</code> without the slice length. This means it’s smaller on the stack, but it means bounds checking is impossible locally, so
accessing elements in the slice is <code>unsafe</code>. In debug builds, the length is included and will be checked.</p>
<p><code>OwningPtr&lt;'a&gt;</code>, <code>Ptr&lt;'a&gt;</code>, and <code>PtrMut&lt;'a&gt;</code> act like <code>NonNull&lt;()&gt;</code>, but attempts to restore much of the safety guarantees of <code>Unique&lt;T&gt;</code>, <code>&amp;T</code>, and <code>&amp;mut T</code>.
They allow working with heterogenous type erased storage (i.e. ECS tables, typemaps) without the overhead of dynamic dispatch in a manner that progressively
translates back to safe borrows. These types also support optional alignment requirements at a type level, and will verify it on dereference in debug builds.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Aligned.html" title="struct bevy_ptr::Aligned">Aligned</a></div><div class="desc docblock-short">Used as a type argument to <a href="struct.Ptr.html" title="struct bevy_ptr::Ptr"><code>Ptr</code></a>, <a href="struct.PtrMut.html" title="struct bevy_ptr::PtrMut"><code>PtrMut</code></a> and <a href="struct.OwningPtr.html" title="struct bevy_ptr::OwningPtr"><code>OwningPtr</code></a> to specify that the pointer is aligned.</div></li><li><div class="item-name"><a class="struct" href="struct.ConstNonNull.html" title="struct bevy_ptr::ConstNonNull">ConstNonNull</a></div><div class="desc docblock-short">A newtype around <a href="https://doc.rust-lang.org/1.79.0/core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull"><code>NonNull</code></a> that only allows conversion to read-only borrows or pointers.</div></li><li><div class="item-name"><a class="struct" href="struct.OwningPtr.html" title="struct bevy_ptr::OwningPtr">OwningPtr</a></div><div class="desc docblock-short">Type-erased Box-like pointer to some unknown type chosen when constructing this type.
Conceptually represents ownership of whatever data is being pointed to and so is
responsible for calling its <code>Drop</code> impl. This pointer is <em>not</em> responsible for freeing
the memory pointed to by this pointer as it may be pointing to an element in a <code>Vec</code> or
to a local in a function etc.</div></li><li><div class="item-name"><a class="struct" href="struct.Ptr.html" title="struct bevy_ptr::Ptr">Ptr</a></div><div class="desc docblock-short">Type-erased borrow of some unknown type chosen when constructing this type.</div></li><li><div class="item-name"><a class="struct" href="struct.PtrMut.html" title="struct bevy_ptr::PtrMut">PtrMut</a></div><div class="desc docblock-short">Type-erased mutable borrow of some unknown type chosen when constructing this type.</div></li><li><div class="item-name"><a class="struct" href="struct.ThinSlicePtr.html" title="struct bevy_ptr::ThinSlicePtr">ThinSlicePtr</a></div><div class="desc docblock-short">Conceptually equivalent to <code>&amp;'a [T]</code> but with length information cut out for performance reasons</div></li><li><div class="item-name"><a class="struct" href="struct.Unaligned.html" title="struct bevy_ptr::Unaligned">Unaligned</a></div><div class="desc docblock-short">Used as a type argument to <a href="struct.Ptr.html" title="struct bevy_ptr::Ptr"><code>Ptr</code></a>, <a href="struct.PtrMut.html" title="struct bevy_ptr::PtrMut"><code>PtrMut</code></a> and <a href="struct.OwningPtr.html" title="struct bevy_ptr::OwningPtr"><code>OwningPtr</code></a> to specify that the pointer is not aligned.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.IsAligned.html" title="trait bevy_ptr::IsAligned">IsAligned</a></div><div class="desc docblock-short">Trait that is only implemented for <a href="struct.Aligned.html" title="struct bevy_ptr::Aligned"><code>Aligned</code></a> and <a href="struct.Unaligned.html" title="struct bevy_ptr::Unaligned"><code>Unaligned</code></a> to work around the lack of ability
to have const generics of an enum.</div></li><li><div class="item-name"><a class="trait" href="trait.UnsafeCellDeref.html" title="trait bevy_ptr::UnsafeCellDeref">UnsafeCellDeref</a></div><div class="desc docblock-short">Extension trait for helper methods on <a href="https://doc.rust-lang.org/1.79.0/core/cell/struct.UnsafeCell.html" title="struct core::cell::UnsafeCell"><code>UnsafeCell</code></a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.dangling_with_align.html" title="fn bevy_ptr::dangling_with_align">dangling_with_align</a></div><div class="desc docblock-short">Creates a dangling pointer with specified alignment.
See <a href="https://doc.rust-lang.org/1.79.0/core/ptr/non_null/struct.NonNull.html#method.dangling" title="associated function core::ptr::non_null::NonNull::dangling"><code>NonNull::dangling</code></a>.</div></li></ul></section></div></main></body></html>