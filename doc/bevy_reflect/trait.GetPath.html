<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait which allows nested `Reflect` values to be retrieved with path strings."><title>GetPath in bevy_reflect - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bevy_reflect" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../bevy_reflect/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../bevy_reflect/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">GetPath</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.reflect_path">reflect_path</a></li><li><a href="#tymethod.reflect_path_mut">reflect_path_mut</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.path">path</a></li><li><a href="#method.path_mut">path_mut</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In bevy_reflect</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="index.html">bevy_reflect</a>::<wbr><a class="trait" href="#">GetPath</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/bevy_reflect/path.rs.html#189-238">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait GetPath {
    // Required methods
    fn <a href="#tymethod.reflect_path" class="fn">reflect_path</a>&lt;'r, 'p&gt;(
        &amp;'r self,
        path: &amp;'p <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;'r dyn <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.reflect_path_mut" class="fn">reflect_path_mut</a>&lt;'r, 'p&gt;(
        &amp;'r mut self,
        path: &amp;'p <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;'r mut dyn <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;;

    // Provided methods
    fn <a href="#method.path" class="fn">path</a>&lt;'r, 'p, T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt;(
        &amp;'r self,
        path: &amp;'p <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;'r T</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.path_mut" class="fn">path_mut</a>&lt;'r, 'p, T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt;(
        &amp;'r mut self,
        path: &amp;'p <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;'r mut T</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt; { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait which allows nested <a href="trait.Reflect.html" title="trait bevy_reflect::Reflect"><code>Reflect</code></a> values to be retrieved with path strings.</p>
<p>Using these functions repeatedly with the same string requires parsing the string every time.
To avoid this cost, it’s recommended to construct a <a href="struct.ParsedPath.html" title="struct bevy_reflect::ParsedPath"><code>ParsedPath</code></a> instead.</p>
<h2 id="syntax"><a href="#syntax">Syntax</a></h2><h3 id="structs"><a href="#structs">Structs</a></h3>
<p>Field paths for <a href="trait.Struct.html" title="trait bevy_reflect::Struct"><code>Struct</code></a> elements use the standard Rust field access syntax of
dot and field name: <code>.field_name</code>.</p>
<p>Additionally, struct fields may be accessed by their index within the struct’s definition.
This is accomplished by using the hash symbol (<code>#</code>) in place of the standard dot: <code>#0</code>.</p>
<p>Accessing a struct’s field by index can speed up fetches at runtime due to the removed
need for string matching.
And while this can be more performant, it’s best to keep in mind the tradeoffs when
utilizing such optimizations.
For example, this can result in fairly fragile code as the string paths will need to be
kept in sync with the struct definitions since the order of fields could be easily changed.
Because of this, storing these kinds of paths in persistent storage (i.e. game assets)
is strongly discouraged.</p>
<p>Note that a leading dot (<code>.</code>) or hash (<code>#</code>) token is implied for the first item in a path,
and may therefore be omitted.</p>
<h4 id="example"><a href="#example">Example</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyStruct {
  value: u32
}

<span class="kw">let </span>my_struct = MyStruct { value: <span class="number">123 </span>};
<span class="comment">// Access via field name
</span><span class="macro">assert_eq!</span>(my_struct.path::&lt;u32&gt;(<span class="string">&quot;.value&quot;</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);
<span class="comment">// Access via field index
</span><span class="macro">assert_eq!</span>(my_struct.path::&lt;u32&gt;(<span class="string">&quot;#0&quot;</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);</code></pre></div>
<h3 id="tuples-and-tuple-structs"><a href="#tuples-and-tuple-structs">Tuples and Tuple Structs</a></h3>
<p><a href="trait.Tuple.html" title="trait bevy_reflect::Tuple"><code>Tuple</code></a> and <a href="trait.TupleStruct.html" title="trait bevy_reflect::TupleStruct"><code>TupleStruct</code></a> elements also follow a conventional Rust syntax.
Fields are accessed with a dot and the field index: <code>.0</code>.</p>
<p>Note that a leading dot (<code>.</code>) token is implied for the first item in a path,
and may therefore be omitted.</p>
<h4 id="example-1"><a href="#example-1">Example</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyTupleStruct(u32);

<span class="kw">let </span>my_tuple_struct = MyTupleStruct(<span class="number">123</span>);
<span class="macro">assert_eq!</span>(my_tuple_struct.path::&lt;u32&gt;(<span class="string">&quot;.0&quot;</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);</code></pre></div>
<h3 id="lists-and-arrays"><a href="#lists-and-arrays">Lists and Arrays</a></h3>
<p><a href="trait.List.html" title="trait bevy_reflect::List"><code>List</code></a> and <a href="trait.Array.html" title="trait bevy_reflect::Array"><code>Array</code></a> elements are accessed with brackets: <code>[0]</code>.</p>
<h4 id="example-2"><a href="#example-2">Example</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_list: Vec&lt;u32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq!</span>(my_list.path::&lt;u32&gt;(<span class="string">&quot;[2]&quot;</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">3</span>);</code></pre></div>
<h3 id="enums"><a href="#enums">Enums</a></h3>
<p>Pathing for <a href="trait.Enum.html" title="trait bevy_reflect::Enum"><code>Enum</code></a> elements works a bit differently than in normal Rust.
Usually, you would need to pattern match an enum, branching off on the desired variants.
Paths used by this trait do not have any pattern matching capabilities;
instead, they assume the variant is already known ahead of time.</p>
<p>The syntax used, therefore, depends on the variant being accessed:</p>
<ul>
<li>Struct variants use the struct syntax (outlined above)</li>
<li>Tuple variants use the tuple syntax (outlined above)</li>
<li>Unit variants have no fields to access</li>
</ul>
<p>If the variant cannot be known ahead of time, the path will need to be split up
and proper enum pattern matching will need to be handled manually.</p>
<h4 id="example-3"><a href="#example-3">Example</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">enum </span>MyEnum {
  Unit,
  Tuple(bool),
  Struct {
    value: u32
  }
}

<span class="kw">let </span>tuple_variant = MyEnum::Tuple(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(tuple_variant.path::&lt;bool&gt;(<span class="string">&quot;.0&quot;</span>).unwrap(), <span class="kw-2">&amp;</span><span class="bool-val">true</span>);

<span class="kw">let </span>struct_variant = MyEnum::Struct { value: <span class="number">123 </span>};
<span class="comment">// Access via field name
</span><span class="macro">assert_eq!</span>(struct_variant.path::&lt;u32&gt;(<span class="string">&quot;.value&quot;</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);
<span class="comment">// Access via field index
</span><span class="macro">assert_eq!</span>(struct_variant.path::&lt;u32&gt;(<span class="string">&quot;#0&quot;</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);

<span class="comment">// Error: Expected struct variant
</span><span class="macro">assert!</span>(<span class="macro">matches!</span>(tuple_variant.path::&lt;u32&gt;(<span class="string">&quot;.value&quot;</span>), <span class="prelude-val">Err</span>(<span class="kw">_</span>)));</code></pre></div>
<h2 id="chaining"><a href="#chaining">Chaining</a></h2>
<p>Using the aforementioned syntax, path items may be chained one after another
to create a full path to a nested element.</p>
<h3 id="example-4"><a href="#example-4">Example</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyStruct {
  value: Vec&lt;<span class="prelude-ty">Option</span>&lt;u32&gt;&gt;
}

<span class="kw">let </span>my_struct = MyStruct {
  value: <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="number">123</span>)],
};
<span class="macro">assert_eq!</span>(
  my_struct.path::&lt;u32&gt;(<span class="string">&quot;.value[2].0&quot;</span>).unwrap(),
  <span class="kw-2">&amp;</span><span class="number">123</span>,
);</code></pre></div>
</div></details><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.reflect_path" class="method"><a class="srclink rightside" href="../src/bevy_reflect/path.rs.html#194-197">source</a><h4 class="code-header">fn <a href="#tymethod.reflect_path" class="fn">reflect_path</a>&lt;'r, 'p&gt;(
    &amp;'r self,
    path: &amp;'p <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;'r dyn <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a reference to the value specified by <code>path</code>.</p>
<p>To retrieve a statically typed reference, use
<a href="trait.GetPath.html#method.path" title="method bevy_reflect::GetPath::path"><code>path</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.reflect_path_mut" class="method"><a class="srclink rightside" href="../src/bevy_reflect/path.rs.html#203-206">source</a><h4 class="code-header">fn <a href="#tymethod.reflect_path_mut" class="fn">reflect_path_mut</a>&lt;'r, 'p&gt;(
    &amp;'r mut self,
    path: &amp;'p <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;'r mut dyn <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable reference to the value specified by <code>path</code>.</p>
<p>To retrieve a statically typed mutable reference, use
<a href="trait.GetPath.html#method.path_mut" title="method bevy_reflect::GetPath::path_mut"><code>path_mut</code></a>.</p>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.path" class="method"><a class="srclink rightside" href="../src/bevy_reflect/path.rs.html#215-220">source</a><h4 class="code-header">fn <a href="#method.path" class="fn">path</a>&lt;'r, 'p, T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt;(
    &amp;'r self,
    path: &amp;'p <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;'r T</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a statically typed reference to the value specified by <code>path</code>.</p>
<p>This will automatically handle downcasting to type <code>T</code>.
The downcast will fail if this value is not of type <code>T</code>
(which may be the case when using dynamic types like <a href="struct.DynamicStruct.html" title="struct bevy_reflect::DynamicStruct"><code>DynamicStruct</code></a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.path_mut" class="method"><a class="srclink rightside" href="../src/bevy_reflect/path.rs.html#229-237">source</a><h4 class="code-header">fn <a href="#method.path_mut" class="fn">path_mut</a>&lt;'r, 'p, T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt;(
    &amp;'r mut self,
    path: &amp;'p <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;'r mut T</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a statically typed mutable reference to the value specified by <code>path</code>.</p>
<p>This will automatically handle downcasting to type <code>T</code>.
The downcast will fail if this value is not of type <code>T</code>
(which may be the case when using dynamic types like <a href="struct.DynamicStruct.html" title="struct bevy_reflect::DynamicStruct"><code>DynamicStruct</code></a>).</p>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-GetPath-for-dyn+Reflect" class="impl"><a class="srclink rightside" href="../src/bevy_reflect/path.rs.html#256-278">source</a><a href="#impl-GetPath-for-dyn+Reflect" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.GetPath.html" title="trait bevy_reflect::GetPath">GetPath</a> for dyn <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a></h3></section><section id="impl-GetPath-for-T" class="impl"><a class="srclink rightside" href="../src/bevy_reflect/path.rs.html#240-254">source</a><a href="#impl-GetPath-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt; <a class="trait" href="trait.GetPath.html" title="trait bevy_reflect::GetPath">GetPath</a> for T</h3></section></div><script src="../implementors/bevy_reflect/path/trait.GetPath.js" async></script></section></div></main></body></html>