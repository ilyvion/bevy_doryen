<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bevy ECS"><title>bevy_ecs - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bevy_ecs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0 (8ede3aae2 2023-07-12)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../bevy_ecs/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../bevy_ecs/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate bevy_ecs</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.11.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">bevy_ecs</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/bevy_ecs/lib.rs.html#1-1726">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="bevy-ecs"><a href="#bevy-ecs">Bevy ECS</a></h2>
<p><a href="https://crates.io/crates/bevy_ecs"><img src="https://img.shields.io/crates/v/bevy_ecs.svg" alt="Crates.io" /></a>
<a href="https://github.com/bevyengine/bevy/blob/HEAD/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="license" /></a>
<a href="https://discord.gg/bevy"><img src="https://img.shields.io/discord/691052431525675048.svg?label=&amp;logo=discord&amp;logoColor=ffffff&amp;color=7389D8&amp;labelColor=6A7EC2" alt="Discord" /></a></p>
<h3 id="what-is-bevy-ecs"><a href="#what-is-bevy-ecs">What is Bevy ECS?</a></h3>
<p>Bevy ECS is an Entity Component System custom-built for the <a href="https://bevyengine.org/">Bevy</a> game engine.
It aims to be simple to use, ergonomic, fast, massively parallel, opinionated, and featureful.
It was created specifically for Bevy’s needs, but it can easily be used as a standalone crate in other projects.</p>
<h3 id="ecs"><a href="#ecs">ECS</a></h3>
<p>All app logic in Bevy uses the Entity Component System paradigm, which is often shortened to ECS. ECS is a software pattern that involves breaking your program up into Entities, Components, and Systems. Entities are unique “things” that are assigned groups of Components, which are then processed using Systems.</p>
<p>For example, one entity might have a <code>Position</code> and <code>Velocity</code> component, whereas another entity might have a <code>Position</code> and <code>UI</code> component. You might have a movement system that runs on all entities with a Position and Velocity component.</p>
<p>The ECS pattern encourages clean, decoupled designs by forcing you to break up your app data and logic into its core components. It also helps make your code faster by optimizing memory access patterns and making parallelism easier.</p>
<h3 id="concepts"><a href="#concepts">Concepts</a></h3>
<p>Bevy ECS is Bevy’s implementation of the ECS pattern. Unlike other Rust ECS implementations, which often require complex lifetimes, traits, builder patterns, or macros, Bevy ECS uses normal Rust data types for all of these concepts:</p>
<h4 id="components"><a href="#components">Components</a></h4>
<p>Components are normal Rust structs. They are data stored in a <code>World</code> and specific instances of Components correlate to Entities.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }</code></pre></div>
<h4 id="worlds"><a href="#worlds">Worlds</a></h4>
<p>Entities, Components, and Resources are stored in a <code>World</code>. Worlds, much like Rust std collections like HashSet and Vec, expose operations to insert, read, write, and remove the data they store.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::world::World;

<span class="kw">let </span>world = World::default();</code></pre></div>
<h4 id="entities"><a href="#entities">Entities</a></h4>
<p>Entities are unique identifiers that correlate to zero or more Components.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Velocity { x: f32, y: f32 }

<span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

<span class="kw">let </span>entity = world
    .spawn((Position { x: <span class="number">0.0</span>, y: <span class="number">0.0 </span>}, Velocity { x: <span class="number">1.0</span>, y: <span class="number">0.0 </span>}))
    .id();

<span class="kw">let </span>entity_ref = world.entity(entity);
<span class="kw">let </span>position = entity_ref.get::&lt;Position&gt;().unwrap();
<span class="kw">let </span>velocity = entity_ref.get::&lt;Velocity&gt;().unwrap();</code></pre></div>
<h4 id="systems"><a href="#systems">Systems</a></h4>
<p>Systems are normal Rust functions. Thanks to the Rust type system, Bevy ECS can use function parameter types to determine what data needs to be sent to the system. It also uses this “data access” information to determine what Systems can run in parallel with each other.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }

<span class="kw">fn </span>print_position(query: Query&lt;(Entity, <span class="kw-2">&amp;</span>Position)&gt;) {
    <span class="kw">for </span>(entity, position) <span class="kw">in </span><span class="kw-2">&amp;</span>query {
        <span class="macro">println!</span>(<span class="string">&quot;Entity {:?} is at position: x {}, y {}&quot;</span>, entity, position.x, position.y);
    }
}</code></pre></div>
<h4 id="resources"><a href="#resources">Resources</a></h4>
<p>Apps often require unique resources, such as asset collections, renderers, audio servers, time, etc. Bevy ECS makes this pattern a first class citizen. <code>Resource</code> is a special kind of component that does not belong to any entity. Instead, it is identified uniquely by its type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Resource, Default)]
</span><span class="kw">struct </span>Time {
    seconds: f32,
}

<span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

world.insert_resource(Time::default());

<span class="kw">let </span>time = world.get_resource::&lt;Time&gt;().unwrap();

<span class="comment">// You can also access resources from Systems
</span><span class="kw">fn </span>print_time(time: Res&lt;Time&gt;) {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, time.seconds);
}</code></pre></div>
<p>The <a href="examples/resources.rs"><code>resources.rs</code></a> example illustrates how to read and write a Counter resource from Systems.</p>
<h4 id="schedules"><a href="#schedules">Schedules</a></h4>
<p>Schedules run a set of Systems according to some execution strategy.
Systems can be added to any number of System Sets, which are used to control their scheduling metadata.</p>
<p>The built in “parallel executor” considers dependencies between systems and (by default) run as many of them in parallel as possible. This maximizes performance, while keeping the system execution safe. To control the system ordering, define explicit dependencies between systems and their sets.</p>
<h3 id="using-bevy-ecs"><a href="#using-bevy-ecs">Using Bevy ECS</a></h3>
<p>Bevy ECS should feel very natural for those familiar with Rust syntax:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Velocity { x: f32, y: f32 }

<span class="comment">// This system moves each entity with a Position and Velocity component
</span><span class="kw">fn </span>movement(<span class="kw-2">mut </span>query: Query&lt;(<span class="kw-2">&amp;mut </span>Position, <span class="kw-2">&amp;</span>Velocity)&gt;) {
    <span class="kw">for </span>(<span class="kw-2">mut </span>position, velocity) <span class="kw">in </span><span class="kw-2">&amp;mut </span>query {
        position.x += velocity.x;
        position.y += velocity.y;
    }
}

<span class="kw">fn </span>main() {
    <span class="comment">// Create a new empty World to hold our Entities and Components
    </span><span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

    <span class="comment">// Spawn an entity with Position and Velocity components
    </span>world.spawn((
        Position { x: <span class="number">0.0</span>, y: <span class="number">0.0 </span>},
        Velocity { x: <span class="number">1.0</span>, y: <span class="number">0.0 </span>},
    ));

    <span class="comment">// Create a new Schedule, which defines an execution strategy for Systems
    </span><span class="kw">let </span><span class="kw-2">mut </span>schedule = Schedule::default();

    <span class="comment">// Add our system to the schedule
    </span>schedule.add_systems(movement);

    <span class="comment">// Run the schedule once. If your app has a &quot;loop&quot;, you would run this once per loop
    </span>schedule.run(<span class="kw-2">&amp;mut </span>world);
}</code></pre></div>
<h3 id="features"><a href="#features">Features</a></h3><h4 id="query-filters"><a href="#query-filters">Query Filters</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Player;
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Alive;

<span class="comment">// Gets the Position component of all Entities with Player component and without the Alive
// component. 
</span><span class="kw">fn </span>system(query: Query&lt;<span class="kw-2">&amp;</span>Position, (With&lt;Player&gt;, Without&lt;Alive&gt;)&gt;) {
    <span class="kw">for </span>position <span class="kw">in </span><span class="kw-2">&amp;</span>query {
    }
}</code></pre></div>
<h4 id="change-detection"><a href="#change-detection">Change Detection</a></h4>
<p>Bevy ECS tracks <em>all</em> changes to Components and Resources.</p>
<p>Queries can filter for changed Components:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Velocity { x: f32, y: f32 }

<span class="comment">// Gets the Position component of all Entities whose Velocity has changed since the last run of the System
</span><span class="kw">fn </span>system_changed(query: Query&lt;<span class="kw-2">&amp;</span>Position, Changed&lt;Velocity&gt;&gt;) {
    <span class="kw">for </span>position <span class="kw">in </span><span class="kw-2">&amp;</span>query {
    }
}

<span class="comment">// Gets the Position component of all Entities that had a Velocity component added since the last run of the System
</span><span class="kw">fn </span>system_added(query: Query&lt;<span class="kw-2">&amp;</span>Position, Added&lt;Velocity&gt;&gt;) {
    <span class="kw">for </span>position <span class="kw">in </span><span class="kw-2">&amp;</span>query {
    }
}</code></pre></div>
<p>Resources also expose change state:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Resource)]
</span><span class="kw">struct </span>Time(f32);

<span class="comment">// Prints &quot;time changed!&quot; if the Time resource has changed since the last run of the System
</span><span class="kw">fn </span>system(time: Res&lt;Time&gt;) {
    <span class="kw">if </span>time.is_changed() {
        <span class="macro">println!</span>(<span class="string">&quot;time changed!&quot;</span>);
    }
}</code></pre></div>
<p>The <a href="examples/change_detection.rs"><code>change_detection.rs</code></a> example shows how to query only for updated entities and react on changes in resources.</p>
<h4 id="component-storage"><a href="#component-storage">Component Storage</a></h4>
<p>Bevy ECS supports multiple component storage types.</p>
<p>Components can be stored in:</p>
<ul>
<li><strong>Tables</strong>: Fast and cache friendly iteration, but slower adding and removing of components. This is the default storage type.</li>
<li><strong>Sparse Sets</strong>: Fast adding and removing of components, but slower iteration.</li>
</ul>
<p>Component storage types are configurable, and they default to table storage if the storage is not manually defined.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>TableStoredComponent;

<span class="attr">#[derive(Component)]
#[component(storage = <span class="string">&quot;SparseSet&quot;</span>)]
</span><span class="kw">struct </span>SparseStoredComponent;</code></pre></div>
<h4 id="component-bundles"><a href="#component-bundles">Component Bundles</a></h4>
<p>Define sets of Components that should be added together.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Default, Component)]
</span><span class="kw">struct </span>Player;
<span class="attr">#[derive(Default, Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Default, Component)]
</span><span class="kw">struct </span>Velocity { x: f32, y: f32 }

<span class="attr">#[derive(Bundle, Default)]
</span><span class="kw">struct </span>PlayerBundle {
    player: Player,
    position: Position,
    velocity: Velocity,
}

<span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

<span class="comment">// Spawn a new entity and insert the default PlayerBundle
</span>world.spawn(PlayerBundle::default());

<span class="comment">// Bundles play well with Rust&#39;s struct update syntax
</span>world.spawn(PlayerBundle {
    position: Position { x: <span class="number">1.0</span>, y: <span class="number">1.0 </span>},
    ..Default::default()
});</code></pre></div>
<h4 id="events"><a href="#events">Events</a></h4>
<p>Events offer a communication channel between one or more systems. Events can be sent using the system parameter <code>EventWriter</code> and received with <code>EventReader</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Event)]
</span><span class="kw">struct </span>MyEvent {
    message: String,
}

<span class="kw">fn </span>writer(<span class="kw-2">mut </span>writer: EventWriter&lt;MyEvent&gt;) {
    writer.send(MyEvent {
        message: <span class="string">&quot;hello!&quot;</span>.to_string(),
    });
}

<span class="kw">fn </span>reader(<span class="kw-2">mut </span>reader: EventReader&lt;MyEvent&gt;) {
    <span class="kw">for </span>event <span class="kw">in </span>reader.iter() {
    }
}</code></pre></div>
<p>A minimal set up using events can be seen in <a href="examples/events.rs"><code>events.rs</code></a>.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.ptr"><code>pub use <a class="mod" href="../bevy_ptr/index.html" title="mod bevy_ptr">bevy_ptr</a> as ptr;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="archetype/index.html" title="mod bevy_ecs::archetype">archetype</a></div><div class="desc docblock-short">Types for defining <a href="archetype/struct.Archetype.html" title="struct bevy_ecs::archetype::Archetype"><code>Archetype</code></a>s, collections of entities that have the same set of
components.</div></li><li><div class="item-name"><a class="mod" href="bundle/index.html" title="mod bevy_ecs::bundle">bundle</a></div><div class="desc docblock-short">Types for handling <a href="bundle/trait.Bundle.html" title="trait bevy_ecs::bundle::Bundle"><code>Bundle</code></a>s.</div></li><li><div class="item-name"><a class="mod" href="change_detection/index.html" title="mod bevy_ecs::change_detection">change_detection</a></div><div class="desc docblock-short">Types that detect when their internal data mutate.</div></li><li><div class="item-name"><a class="mod" href="component/index.html" title="mod bevy_ecs::component">component</a></div><div class="desc docblock-short">Types for declaring and storing <a href="component/trait.Component.html" title="trait bevy_ecs::component::Component"><code>Component</code></a>s.</div></li><li><div class="item-name"><a class="mod" href="entity/index.html" title="mod bevy_ecs::entity">entity</a></div><div class="desc docblock-short">Entity handling types.</div></li><li><div class="item-name"><a class="mod" href="event/index.html" title="mod bevy_ecs::event">event</a></div><div class="desc docblock-short">Event handling types.</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod bevy_ecs::prelude">prelude</a></div><div class="desc docblock-short">Most commonly used re-exported types.</div></li><li><div class="item-name"><a class="mod" href="query/index.html" title="mod bevy_ecs::query">query</a></div><div class="desc docblock-short">Contains APIs for retrieving component data from the world.</div></li><li><div class="item-name"><a class="mod" href="reflect/index.html" title="mod bevy_ecs::reflect">reflect</a></div><div class="desc docblock-short">Types that enable reflection support.</div></li><li><div class="item-name"><a class="mod" href="removal_detection/index.html" title="mod bevy_ecs::removal_detection">removal_detection</a></div><div class="desc docblock-short">Alerting events when a component is removed from an entity.</div></li><li><div class="item-name"><a class="mod" href="schedule/index.html" title="mod bevy_ecs::schedule">schedule</a></div><div class="desc docblock-short">Contains APIs for ordering systems and executing them on a <a href="world/struct.World.html" title="struct bevy_ecs::world::World"><code>World</code></a></div></li><li><div class="item-name"><a class="mod" href="storage/index.html" title="mod bevy_ecs::storage">storage</a></div><div class="desc docblock-short">Storage layouts for ECS data.</div></li><li><div class="item-name"><a class="mod" href="system/index.html" title="mod bevy_ecs::system">system</a></div><div class="desc docblock-short">Tools for controlling behavior in an ECS application.</div></li><li><div class="item-name"><a class="mod" href="world/index.html" title="mod bevy_ecs::world">world</a></div><div class="desc docblock-short">Defines the <a href="world/struct.World.html" title="struct bevy_ecs::world::World"><code>World</code></a> and APIs for accessing it directly.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.all_tuples.html" title="macro bevy_ecs::all_tuples">all_tuples</a></div><div class="desc docblock-short">Helper macro to generate tuple pyramids. Useful to generate scaffolding to work around Rust
lacking variadics. Invoking <code>all_tuples!(impl_foo, start, end, P, Q, ..)</code>
invokes <code>impl_foo</code> providing ident tuples through arity <code>start..=end</code>.</div></li></ul></section></div></main></body></html>